class FreePaymentSystem{constructor(){this.paymentMethods=[{id:"paypal",name:"PayPal",fee:.029},{id:"stripe",name:"Stripe",fee:.029},{id:"crypto",name:"Cryptocurrency",fee:.01}];this.transactions=[];this.init()}init(){this.loadTransactions();console.log("Free Payment System initialized")}processPayment(amount,method,description){return new Promise((resolve,reject)=>{setTimeout(()=>{try{if(amount<=0){throw new Error("Invalid amount")}const paymentMethod=this.paymentMethods.find(m=>m.id===method);if(!paymentMethod){throw new Error("Invalid payment method")}const fee=amount*paymentMethod.fee;const netAmount=amount-fee;const transactionData={id:this.generateTransactionId(),amount:amount,fee:fee,netAmount:netAmount,method:method,description:description,timestamp:(new Date).toISOString(),status:"completed"};let signedTransaction=transactionData;let transactionSignature=null;if(window.gameSecurity){const signature=window.gameSecurity.signTransaction(transactionData);signedTransaction=signature.signedData;transactionSignature=signature.hash;console.log("Transaction signed with hash:",transactionSignature)}const transactionRecord={id:transactionData.id,amount:amount,fee:fee,netAmount:netAmount,method:method,description:description,timestamp:(new Date).toISOString(),status:"completed",signedData:signedTransaction,signature:transactionSignature};this.transactions.push(transactionRecord);this.saveTransactions();console.log(`Payment processed: $${amount} via ${paymentMethod.name}`);console.log(`Fees: $${fee.toFixed(2)}, Net: $${netAmount.toFixed(2)}`);resolve(transactionRecord)}catch(error){console.error("Payment processing error:",error);reject(error)}},1e3)})}processCryptoPayment(amount,cryptoType,walletAddress){return new Promise((resolve,reject)=>{setTimeout(()=>{try{if(amount<=0){throw new Error("Invalid amount")}const validCryptos=["bitcoin","ethereum","litecoin"];if(!validCryptos.includes(cryptoType)){throw new Error("Invalid cryptocurrency type")}const cryptoRates={bitcoin:5e4,ethereum:3e3,litecoin:150};const cryptoAmount=amount/cryptoRates[cryptoType];const transactionData={amount:amount,cryptoAmount:cryptoAmount,cryptoType:cryptoType,walletAddress:walletAddress,timestamp:(new Date).toISOString()};let encodedData=btoa(JSON.stringify(transactionData));if(window.gameSecurity){encodedData=window.gameSecurity.secureBase64Encode(transactionData);console.log("Securely encoded transaction data")}const transaction={id:this.generateTransactionId(),amount:amount,cryptoAmount:cryptoAmount,cryptoType:cryptoType,walletAddress:walletAddress,encodedData:encodedData,timestamp:(new Date).toISOString(),status:"pending"};this.transactions.push(transaction);this.saveTransactions();console.log(`Crypto payment initiated: $${amount} (${cryptoAmount.toFixed(6)} ${cryptoType.toUpperCase()})`);console.log(`Encoded transaction data: ${encodedData.substring(0,50)}...`);resolve({transactionId:transaction.id,amount:amount,cryptoAmount:cryptoAmount,cryptoType:cryptoType,encodedData:encodedData,message:`Send ${cryptoAmount.toFixed(6)} ${cryptoType.toUpperCase()} to wallet address: ${walletAddress}`})}catch(error){console.error("Crypto payment processing error:",error);reject(error)}},1500)})}verifyTransaction(transactionId){const transaction=this.transactions.find(t=>t.id===transactionId);if(!transaction){return{valid:false,error:"Transaction not found"}}if(transaction.signature&&window.gameSecurity){const verification=window.gameSecurity.verifyTransaction(transaction.signedData);return verification}return{valid:true,data:{id:transaction.id,amount:transaction.amount,method:transaction.method,timestamp:transaction.timestamp,status:transaction.status}}}decodeTransactionData(encodedData){try{if(window.gameSecurity){const decoded=window.gameSecurity.secureBase64Decode(encodedData);if(decoded){return decoded}}const jsonString=atob(encodedData);return JSON.parse(jsonString)}catch(e){console.error("Failed to decode transaction data:",e);return null}}generateTransactionId(){return"txn_"+Date.now()+"_"+Math.random().toString(36).substr(2,9)}loadTransactions(){try{const data=localStorage.getItem("payment_transactions");if(data){this.transactions=JSON.parse(data)}}catch(e){console.log("Error loading transactions:",e);this.transactions=[]}}saveTransactions(){try{localStorage.setItem("payment_transactions",JSON.stringify(this.transactions))}catch(e){console.log("Error saving transactions:",e)}}getTransactionHistory(){return this.transactions.slice().reverse()}getTotalRevenue(){return this.transactions.filter(t=>t.status==="completed").reduce((sum,t)=>sum+(t.netAmount||t.amount),0)}getTotalFees(){return this.transactions.filter(t=>t.status==="completed").reduce((sum,t)=>sum+(t.fee||0),0)}}const paymentSystem=new FreePaymentSystem;window.paymentSystem=paymentSystem;